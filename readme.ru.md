# decode-date

```npm install decode-date```

### Быстрый код получения частей даты из unicode timestamp 
```
const { jsDecodeDate } = require('decode-date');

const now = Date.now();
const info = jsDecodeDate(now);
console.log(info);

```
### Вернёт объект, содержащий информацию даты по гринвичу.
```
{
  timestamp: 1621252530175,
  week: 1,      // номер дня недели (0-7), начиная с воскресенья
  year: 2021,   // год
  month: 4,     // номер месяца (0-11)
  day: 17,      // день месяца (1--31)
  hour: 11,     // час (0-23)
  minute: 55,   // минута (0-59) 
  second: 30,   // секунда (0-59)
  msec: 175     // милисекунды (0-999)
}
```

Функция коорректно и быстро работает начиная с 01.03.0000 по 01.01.4903 гг. Если timestamp выходит за эти пределы, то используются стандартные методы класса Date().

По факту не рекомендуется использовать timestamp для дат старее 14.09.1752, до появления Грегорианского каледаря. Так же не рекомендуется верить историкам. Ибо истоию пишут победители чтобы легче было удерживать свою власть и оправдывать свои злодеяния.

### Тестирование

Версия Ноды: ```Node v14.16```

Для тестирования написал тело функции на Си с компиляцией в WASM.
В итоге, оказалось, что преимуществ в этой технологии нету. Так как много процессорного времени затрачивается на непосредственный вызов функции и на передачу значений через буфер обмена.

Для компиляции использовал ресурсы
[webassembly.studio](https://webassembly.studio/) или [WasmFiddle](https://wasdk.github.io/WasmFiddle/)

Результат тестирования, операций в секунду:
```
 2440144 dateDecodeDate        //native: date.getUTCFullYear()...
 8580758 jsDecodeDate          //by js
 8370737 wasmDecodeDateA       //by wasm
 8110711 wasmDecodeDateB       //by wasm
 8550755 wasmDecodeDateC       //by wasm
15491449 wasmDecodeDate_C_Proc //by wasm without read values from memory
```
Более, чем в 3 раза код (```jsDecodeDate```) быстрее, чем методы класса ```Date()```. 

А для кода ```WASM``` половину процессорного времени уходит на передачу данных. Получается, что нет нужды использовать ```WASM```, пока не оптимизируют его до нормального уровня. Так в ходе тестирования возникло подозрение, что в ```WASM``` медлено происходит конвертация из ```float``` в ```integer```. Технология ещё сырая.


